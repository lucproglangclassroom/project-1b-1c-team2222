# TopWords Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build a streaming word cloud tool that reads words from stdin and outputs updated word frequency statistics using a sliding window, following the Observer pattern.

**Architecture:** Observer pattern separating computation from I/O (matching the instructor's iterators-scala reference). A `TopWordsComputation` trait processes words and emits `Seq[(String, Int)]` results to an `Observer`. For production, a `StdoutObserver` prints formatted output. For testing, an `OutputToBuffer` collects results. Uses mainargs for CLI parsing and scala-logging/logback for diagnostic output.

**Tech Stack:** Scala 3.7.4, SBT, mainargs 0.7.8, scala-logging + logback, ScalaTest + ScalaCheck, sbt-native-packager, sbt-scoverage

---

### Task 1: Update Build Configuration

**Files:**
- Modify: `build.sbt`
- Modify: `README.md`

**Step 1: Update build.sbt**

Replace entire contents of `build.sbt` with:

```scala
name := "topwords-scala"

version := "0.1"

libraryDependencies ++= Seq(
  "com.lihaoyi"                %% "mainargs"        % "0.7.8",
  "com.typesafe.scala-logging" %% "scala-logging"   % "3.9.5",
  "ch.qos.logback"              % "logback-classic"  % "1.5.6",
  "org.scalatest"              %% "scalatest"        % "3.2.19"   % Test,
  "org.scalacheck"             %% "scalacheck"       % "1.19.0"   % Test,
  "org.scalatestplus"          %% "scalacheck-1-18"  % "3.2.19.0" % Test
)

enablePlugins(JavaAppPackaging)
```

**Step 2: Verify it compiles**

Run: `sbt compile`
Expected: Success (no source errors yet since we haven't changed sources)

**Step 3: Commit**

```bash
git add build.sbt
git commit -m "chore: update build.sbt for topwords project with logging deps"
```

---

### Task 2: Remove Old Echo Code and Create Package Structure

**Files:**
- Delete: `src/main/scala/main/Echo.scala`
- Delete: `src/main/scala/main/Main.scala`
- Delete: `src/main/scala/main/Interactive.scala`
- Delete: `src/main/scala/impl/SimpleEcho.scala`
- Delete: `src/main/scala/impl/DoubleEcho.scala`
- Delete: `src/test/scala/impl/EchoTest.scala`
- Delete: `src/test/scala/impl/EchoCheck.scala`
- Delete: `src/test/scala/impl/EchoSpec.scala`
- Delete: `src/test/scala/impl/EchoJUnit.scala`

**Step 1: Remove all echo source and test files**

```bash
rm -rf src/main/scala/main/ src/main/scala/impl/ src/test/scala/impl/
```

**Step 2: Create new directory structure**

```bash
mkdir -p src/main/scala/edu/luc/cs/cs371/topwords
mkdir -p src/test/scala/edu/luc/cs/cs371/topwords
mkdir -p src/main/resources
```

**Step 3: Commit**

```bash
git add -A
git commit -m "chore: remove echo starter code, create topwords package structure"
```

---

### Task 3: Create Observer Traits (common.scala)

**Files:**
- Create: `src/main/scala/edu/luc/cs/cs371/topwords/common.scala`

**Step 1: Write the test for OutputToBuffer observer**

Create `src/test/scala/edu/luc/cs/cs371/topwords/TestObserver.scala`:

```scala
package edu.luc.cs.cs371.topwords

import org.scalatest.funsuite.AnyFunSuite

class TestObserver extends AnyFunSuite:

  test("OutputToBuffer should collect updates"):
    val obs = new OutputToBuffer:
      override type Result = String
    obs.update("hello")
    obs.update("world")
    assert(obs.buffer == Seq("hello", "world"))

  test("OutputToBuffer should start empty"):
    val obs = new OutputToBuffer:
      override type Result = Int
    assert(obs.buffer.isEmpty)

end TestObserver
```

**Step 2: Run test to verify it fails**

Run: `sbt test`
Expected: Compilation error - `OutputToBuffer` not found.

**Step 3: Write common.scala with Observer traits**

Create `src/main/scala/edu/luc/cs/cs371/topwords/common.scala`:

```scala
package edu.luc.cs.cs371.topwords

import scala.collection.mutable.Buffer

/** Observer pattern: receives computation results. */
trait Observer:
  type Result
  def update(result: Result): Unit
end Observer

/** Observer that prints formatted word cloud to stdout with SIGPIPE handling. */
trait StdoutObserver extends Observer:
  override type Result = Seq[(String, Int)]
  override def update(result: Result): Unit =
    val line = result.map((w, f) => s"$w: $f").mkString(" ")
    println(line)
    if scala.sys.process.stdout.checkError() then
      sys.exit(1)
end StdoutObserver

/** Observer that collects results in a buffer for testing. */
trait OutputToBuffer extends Observer:
  val buffer: Buffer[Result] = Buffer.empty[Result]
  override def update(result: Result): Unit = buffer.append(result)
end OutputToBuffer
```

**Step 4: Run test to verify it passes**

Run: `sbt test`
Expected: PASS

**Step 5: Commit**

```bash
git add src/main/scala/edu/luc/cs/cs371/topwords/common.scala src/test/scala/edu/luc/cs/cs371/topwords/TestObserver.scala
git commit -m "feat: add Observer traits (StdoutObserver, OutputToBuffer)"
```

---

### Task 4: Create TopWords Computation Core

**Files:**
- Create: `src/main/scala/edu/luc/cs/cs371/topwords/TopWords.scala`
- Create: `src/test/scala/edu/luc/cs/cs371/topwords/TestTopWords.scala`

**Step 1: Write the failing tests**

Create `src/test/scala/edu/luc/cs/cs371/topwords/TestTopWords.scala`:

```scala
package edu.luc.cs.cs371.topwords

import org.scalatest.funsuite.AnyFunSuite

class TestTopWords extends AnyFunSuite:

  /** Helper: create a testable TopWordsComputation with OutputToBuffer. */
  def createSUT(cloudSize: Int = 10, minLength: Int = 6, windowSize: Int = 1000, ignoreSet: Set[String] = Set.empty) =
    new TopWordsComputation with OutputToBuffer:
      override type Result = Seq[(String, Int)]
      override val howMany = cloudSize
      override val atLeast = minLength
      override val lastNWords = windowSize
      override val ignore = ignoreSet

  // --- Empty / short input ---

  test("empty input produces no output"):
    val sut = createSUT()
    sut.process(Iterator.empty)
    assert(sut.buffer.isEmpty)

  test("input shorter than window produces no output"):
    val sut = createSUT(cloudSize = 3, minLength = 2, windowSize = 5)
    sut.process(Seq("aa", "bb", "cc", "dd").iterator)
    assert(sut.buffer.isEmpty)

  // --- Basic window behavior ---

  test("output starts when window is full"):
    val sut = createSUT(cloudSize = 3, minLength = 2, windowSize = 3)
    sut.process(Seq("aa", "bb", "cc").iterator)
    assert(sut.buffer.size == 1)
    // all words have freq 1
    val result = sut.buffer.head
    assert(result.size == 3)
    assert(result.forall((_, f) => f == 1))

  test("words below minLength are ignored"):
    val sut = createSUT(cloudSize = 3, minLength = 2, windowSize = 5)
    // "a", "b", "c" are too short (length 1 < 2)
    sut.process(Seq("a", "b", "c", "aa", "bb", "cc", "dd").iterator)
    // only aa, bb, cc, dd qualify; window=5, so 4 qualifying words < 5 → no output
    assert(sut.buffer.isEmpty)

  test("words below minLength ignored, enough qualifying words produce output"):
    val sut = createSUT(cloudSize = 3, minLength = 2, windowSize = 3)
    sut.process(Seq("a", "aa", "b", "bb", "c", "cc").iterator)
    assert(sut.buffer.size == 1)

  // --- Sliding window eviction ---

  test("sliding window evicts oldest word"):
    val sut = createSUT(cloudSize = 3, minLength = 2, windowSize = 3)
    // feed 4 words: aa, bb, cc, dd
    // at word 3 (cc): window=[aa,bb,cc], output aa:1 bb:1 cc:1
    // at word 4 (dd): evict aa, window=[bb,cc,dd], output bb:1 cc:1 dd:1
    sut.process(Seq("aa", "bb", "cc", "dd").iterator)
    assert(sut.buffer.size == 2)
    val last = sut.buffer.last
    assert(!last.exists((w, _) => w == "aa")) // aa was evicted
    assert(last.exists((w, _) => w == "dd"))   // dd is present

  test("frequency updates correctly with repeated words"):
    val sut = createSUT(cloudSize = 3, minLength = 2, windowSize = 5)
    sut.process(Seq("aa", "bb", "aa", "bb", "aa").iterator)
    assert(sut.buffer.size == 1)
    val result = sut.buffer.head
    // window=[aa,bb,aa,bb,aa], freq: aa=3, bb=2
    assert(result.head == ("aa", 3))
    assert(result(1) == ("bb", 2))

  // --- Cloud size limiting ---

  test("cloud size limits output"):
    val sut = createSUT(cloudSize = 2, minLength = 2, windowSize = 5)
    sut.process(Seq("aa", "bb", "cc", "dd", "ee").iterator)
    assert(sut.buffer.size == 1)
    assert(sut.buffer.head.size == 2) // only top 2

  test("cloud size larger than distinct words shows fewer"):
    val sut = createSUT(cloudSize = 10, minLength = 2, windowSize = 3)
    sut.process(Seq("aa", "aa", "aa").iterator)
    assert(sut.buffer.size == 1)
    assert(sut.buffer.head == Seq(("aa", 3)))

  // --- Boundary cases ---

  test("window size 1"):
    val sut = createSUT(cloudSize = 3, minLength = 2, windowSize = 1)
    sut.process(Seq("aa", "bb", "cc").iterator)
    assert(sut.buffer.size == 3)
    assert(sut.buffer(0) == Seq(("aa", 1)))
    assert(sut.buffer(1) == Seq(("bb", 1)))
    assert(sut.buffer(2) == Seq(("cc", 1)))

  // --- Ignore list ---

  test("ignore list filters words"):
    val sut = createSUT(cloudSize = 3, minLength = 2, windowSize = 3, ignoreSet = Set("bb"))
    sut.process(Seq("aa", "bb", "cc", "dd").iterator)
    // bb is ignored, qualifying: aa, cc, dd → window full at dd
    assert(sut.buffer.size == 1)
    assert(!sut.buffer.head.exists((w, _) => w == "bb"))

  // --- Full example from assignment spec ---

  test("assignment example: -c 3 -l 2 -w 5"):
    val sut = createSUT(cloudSize = 3, minLength = 2, windowSize = 5)
    val words = Seq("a", "b", "c", "aa", "bb", "cc", "aa", "bb", "aa", "bb", "a", "b", "c", "aa", "aa", "aa")
    sut.process(words.iterator)
    // expected outputs:
    // 1: bb:2 aa:2 cc:1
    // 2: bb:2 aa:2 cc:1
    // 3: bb:2 aa:2 cc:1
    // 4: aa:3 bb:2
    // 5: aa:3 bb:2
    // 6: aa:4 bb:1
    assert(sut.buffer.size == 6)
    // Check first output
    val first = sut.buffer.head
    assert(first.size == 3)
    assert(first.exists((w, f) => w == "bb" && f == 2))
    assert(first.exists((w, f) => w == "aa" && f == 2))
    assert(first.exists((w, f) => w == "cc" && f == 1))
    // Check last output
    val last = sut.buffer.last
    assert(last.head == ("aa", 4))
    assert(last(1) == ("bb", 1))

end TestTopWords
```

**Step 2: Run tests to verify they fail**

Run: `sbt test`
Expected: Compilation error - `TopWordsComputation` not found.

**Step 3: Write the TopWords computation**

Create `src/main/scala/edu/luc/cs/cs371/topwords/TopWords.scala`:

```scala
package edu.luc.cs.cs371.topwords

import scala.collection.mutable

/** Core computation for the streaming word cloud. Depends on an Observer mixin. */
trait TopWordsComputation:
  self: Observer =>
  override type Result = Seq[(String, Int)]

  val howMany: Int
  val atLeast: Int
  val lastNWords: Int
  val ignore: Set[String]

  def process(words: Iterator[String]): Unit =
    val window = mutable.Queue.empty[String]
    val freq = mutable.Map.empty[String, Int]

    for word <- words do
      if word.length >= atLeast && !ignore.contains(word) then
        // Add new word to window and update frequency
        window.enqueue(word)
        freq(word) = freq.getOrElse(word, 0) + 1

        if window.size > lastNWords then
          // Evict oldest word
          val oldest = window.dequeue()
          val oldCount = freq(oldest)
          if oldCount == 1 then
            freq.remove(oldest)
          else
            freq(oldest) = oldCount - 1

        if window.size >= lastNWords then
          // Produce word cloud: top howMany words by frequency descending
          val cloud = freq.toSeq.sortBy(-_(1)).take(howMany)
          update(cloud)

end TopWordsComputation
```

**Step 4: Run tests to verify they pass**

Run: `sbt test`
Expected: ALL PASS

**Step 5: Commit**

```bash
git add src/main/scala/edu/luc/cs/cs371/topwords/TopWords.scala src/test/scala/edu/luc/cs/cs371/topwords/TestTopWords.scala
git commit -m "feat: add TopWordsComputation with sliding window and tests"
```

---

### Task 5: Create Main Entry Point with CLI Parsing and Logging

**Files:**
- Create: `src/main/scala/edu/luc/cs/cs371/topwords/Main.scala`
- Create: `src/main/resources/logback.xml`

**Step 1: Create logback configuration**

Create `src/main/resources/logback.xml`:

```xml
<configuration>
  <appender name="STDERR" class="ch.qos.logback.core.ConsoleAppender">
    <target>System.err</target>
    <encoder>
      <pattern>[%thread] %level %logger - %msg%n</pattern>
    </encoder>
  </appender>
  <root level="DEBUG">
    <appender-ref ref="STDERR" />
  </root>
</configuration>
```

**Step 2: Create Main.scala**

Create `src/main/scala/edu/luc/cs/cs371/topwords/Main.scala`:

```scala
package edu.luc.cs.cs371.topwords

import mainargs.{ParserForMethods, arg, main}
import com.typesafe.scalalogging.LazyLogging

given CanEqual[AnyRef | Null, Null] = CanEqual.derived

object Main extends LazyLogging:

  @main
  def run(
    @arg(short = 'c', doc = "size of the word cloud") cloudSize: Int = 10,
    @arg(short = 'l', doc = "minimum word length") lengthAtLeast: Int = 6,
    @arg(short = 'w', doc = "size of the sliding window") windowSize: Int = 1000,
    @arg(short = 'i', doc = "file of words to ignore") ignoreFile: Option[String] = None
  ): Unit =

    require(cloudSize > 0, "cloud-size must be positive")
    require(lengthAtLeast > 0, "length-at-least must be positive")
    require(windowSize > 0, "window-size must be positive")

    val ignoreSet: Set[String] = ignoreFile match
      case Some(path) =>
        val source = scala.io.Source.fromFile(path)
        try source.getLines().map(_.trim).filter(_.nonEmpty).toSet
        finally source.close()
      case None => Set.empty

    logger.debug(s"howMany=$cloudSize minLength=$lengthAtLeast lastNWords=$windowSize")

    val computation = new TopWordsComputation with StdoutObserver:
      override val howMany = cloudSize
      override val atLeast = lengthAtLeast
      override val lastNWords = windowSize
      override val ignore = ignoreSet

    val words =
      import scala.language.unsafeNulls
      scala.io.Source.stdin.getLines().flatMap(l => l.split("(?U)[^\\p{Alpha}0-9']+")).filter(_.nonEmpty)

    computation.process(words)

  def main(args: Array[String]): Unit =
    ParserForMethods(this).runOrExit(args.toIndexedSeq)
    ()

end Main
```

**Step 3: Verify it compiles and runs**

Run: `sbt compile`
Expected: Success

Run: `echo "hello world" | sbt "runMain edu.luc.cs.cs371.topwords.Main -c 2 -l 2 -w 2"`
Expected: Outputs a word cloud line.

**Step 4: Commit**

```bash
git add src/main/scala/edu/luc/cs/cs371/topwords/Main.scala src/main/resources/logback.xml
git commit -m "feat: add Main entry point with mainargs CLI parsing and logback logging"
```

---

### Task 6: Stage and Test the Native Packager Binary

**Files:**
- No new files

**Step 1: Build the staged binary**

Run: `sbt stage`
Expected: Creates `./target/universal/stage/bin/topwords-scala`

**Step 2: Test with the assignment examples**

Run: `echo "a b c aa bb cc aa bb aa bb a b c aa aa aa" | tr ' ' '\n' | ./target/universal/stage/bin/topwords-scala -c 3 -l 2 -w 5`

Expected output (6 lines):
```
bb: 2 aa: 2 cc: 1
bb: 2 aa: 2 cc: 1
bb: 2 aa: 2 cc: 1
aa: 3 bb: 2
aa: 3 bb: 2
aa: 4 bb: 1
```

**Step 3: Test SIGPIPE handling**

Run: `yes "hello world testing" | ./target/universal/stage/bin/topwords-scala -c 2 -l 5 -w 10 | head -5`
Expected: Outputs 5 lines and exits cleanly (no broken pipe error).

**Step 4: Test scalability (constant space)**

Run: `yes helloworld | timeout 10 ./target/universal/stage/bin/topwords-scala > /dev/null`
Expected: Runs for 10 seconds without growing memory, exits cleanly.

**Step 5: Commit (only if any fixes were needed)**

---

### Task 7: Run Coverage Report

**Files:**
- No new files

**Step 1: Generate coverage report**

Run: `sbt clean coverage test coverageReport`
Expected: At least 80% statement coverage.

**Step 2: Check the report**

Open: `target/scala-3.7.4/scoverage-report/index.html`
Expected: Green coverage on TopWordsComputation and Observer traits.

**Step 3: If coverage is below 80%, add more tests**

Consider adding tests for:
- Empty words (after split, some may be empty strings)
- Very long input sequences
- All words below minimum length

---

### Task 8: Update README and Create LLM Documentation

**Files:**
- Modify: `README.md`
- Create: `doc/llm-interactions.md`

**Step 1: Update README.md**

Replace contents with:

```markdown
# TopWords - Streaming Word Cloud

A streaming word cloud tool that reads words from stdin and outputs updated word frequency statistics using a sliding window approach.

## Usage

```
./topwords --cloud-size howmany --length-at-least minlength --window-size lastnwords
```

Defaults: cloud-size=10, length-at-least=6, window-size=1000.

### Options

- `-c, --cloud-size` - Number of words to show in the cloud (default: 10)
- `-l, --length-at-least` - Minimum word length to consider (default: 6)
- `-w, --window-size` - Sliding window size (default: 1000)
- `-i, --ignore-file` - Path to file of words to ignore (one per line)

## Building and Running

```bash
sbt stage
./target/universal/stage/bin/topwords-scala < input.txt
```

## Running Tests

```bash
sbt test
```

## Test Coverage

```bash
sbt clean coverage test coverageReport
```

Report: `target/scala-3.7.4/scoverage-report/index.html`

## Extra Credit Features

- **Ignore list**: Use `--ignore-file` to specify a file of words to ignore regardless of length.

## Architecture

Uses the Observer design pattern to separate computation from I/O:
- `TopWordsComputation` - core sliding window + frequency tracking
- `StdoutObserver` - production output with SIGPIPE handling
- `OutputToBuffer` - test observer collecting structured results

## Scalability

Runs in constant space using a bounded queue and frequency map. Verified with:
```bash
yes helloworld | ./target/universal/stage/bin/topwords-scala > /dev/null
```
```

**Step 2: Create LLM interaction documentation**

Create `doc/llm-interactions.md`:

Document the conversation with Claude including:
- Design decisions made
- Architecture chosen (Observer pattern)
- Key implementation choices

**Step 3: Commit**

```bash
git add README.md doc/llm-interactions.md
git commit -m "docs: update README for topwords, add LLM interaction docs"
```

---

### Task 9: Final Verification

**Step 1: Run full test suite**

Run: `sbt clean test`
Expected: All tests pass.

**Step 2: Run coverage**

Run: `sbt clean coverage test coverageReport`
Expected: >= 80% coverage.

**Step 3: Build and test binary**

Run: `sbt stage`
Then run the assignment examples and verify output matches.

**Step 4: Test with empty input**

Run: `echo "" | ./target/universal/stage/bin/topwords-scala -c 3 -l 2 -w 5`
Expected: No output (no qualifying words).

**Step 5: Test SIGPIPE**

Run: `yes "hello world testing" | ./target/universal/stage/bin/topwords-scala | head -1`
Expected: One line, clean exit.
